Q-1)

#include <iostream>
#include <unordered_set>
using namespace std;

bool containsDuplicate(int nums[], int n) {
    unordered_set<int> s;

    for (int i = 0; i < n; i++) {
        if (s.count(nums[i]))      // duplicate found
            return true;
        s.insert(nums[i]);
    }
    return false;
}

int main() {
    int nums[] = {1, 2, 3, 1};
    int n = 4;

    cout << (containsDuplicate(nums, n) ? "true" : "false");
}


Q-2)

#include <iostream>
#include <unordered_set>
using namespace std;

int main() {
    int A[] = {1, 2, 3, 4};
    int B[] = {3, 4, 5, 6};

    unordered_set<int> s(A, A + 4);

    cout << "Common elements: ";
    for (int i = 0; i < 4; i++) {
        if (s.count(B[i]))
            cout << B[i] << " ";
    }
}


Q-3)

#include <iostream>
#include <unordered_map>
using namespace std;

int main() {
    int nums[] = {2, 3, 2, 4, 3, 2};
    int n = 6;

    unordered_map<int, int> freq;

    for (int i = 0; i < n; i++)
        freq[nums[i]]++;

    for (auto &p : freq)
        cout << p.first << " â†’ " << p.second << " times\n";
}


Q-4)

#include <iostream>
#include <unordered_map>
using namespace std;

int firstNonRepeating(int nums[], int n) {
    unordered_map<int, int> freq;

    for (int i = 0; i < n; i++)
        freq[nums[i]]++;

    for (int i = 0; i < n; i++)
        if (freq[nums[i]] == 1)
            return nums[i];

    return -1; // no non-repeating
}

int main() {
    int arr[] = {4, 5, 1, 2, 0, 4};
    int n = 6;

    cout << firstNonRepeating(arr, n);
}


Q-5)

#include <iostream>
#include <unordered_set>
using namespace std;

class Node {
public:
    int data;
    Node* next;
    Node(int d) { data = d; next = NULL; }
};

bool hasCycle(Node* head) {
    unordered_set<Node*> visited;

    while (head != NULL) {
        if (visited.count(head))
            return true;     // cycle found
        visited.insert(head);
        head = head->next;
    }
    return false;
}

int main() {
    Node* n1 = new Node(1);
    Node* n2 = new Node(2);
    Node* n3 = new Node(3);
    Node* n4 = new Node(4);

    n1->next = n2;
    n2->next = n3;
    n3->next = n4;
    n4->next = n2;  // cycle back to 2

    cout << (hasCycle(n1) ? "true" : "false");
}


Q-6)

#include <iostream>
#include <unordered_set>
using namespace std;

class Node {
public:
    int data;
    Node* left;
    Node* right;
    Node(int d) { data = d; left = right = NULL; }
};

bool checkDuplicate(Node* root, unordered_set<int>& s) {
    if (root == NULL) return false;

    if (s.count(root->data))
        return true;  // duplicate found

    s.insert(root->data);

    return checkDuplicate(root->left, s) ||
           checkDuplicate(root->right, s);
}

int main() {
    // Example tree
    Node* root = new Node(5);
    root->left = new Node(3);
    root->right = new Node(7);
    root->left->left = new Node(3);   // duplicate

    unordered_set<int> s;

    if (checkDuplicate(root, s))
        cout << "Duplicates Found";
    else
        cout << "No Duplicates";
}
